#' @title Get Laboratory Test Results (LB) domain Z-score for a given STUDYID from SQLite Database or `.xpt` Files
#'
#' @description
#' This function computes the LB Z-score for a given STUDYID using data stored in a specified database.
#' It offers various optional parameters to customize the output, such as whether to return individual scores or Z-scores by `USUBJID`.
#' Organ difference: The difference between LIVER and KIDNEY lb function lies in two areas;
#'                   1) R#117: organTESTCDlist where the list of bio marker differs between two organs
#'                   2) R#172: Calculate z-scores for all kidney bio markers
#'                   3) To do:develop a default organ lb_score by adding an organ parameter:
#'                            will need as many if_else statements as per the organs and associated 1) for organ and 2) bio markers
#' The function has been tested by connecting to SQLite data based using .db file.
#' The studyid and path_db are mandatory input parameters
#'
#' @param studyid Character. STUDYID number. Defaults to `NULL`.
#'    Required for SQLite databases (`use_xpt_file = FALSE`).
#'    Must be `NULL` for `.xpt` files (`use_xpt_file = TRUE`).
#' @param path_db Character. Path to the SQLite database file or a folder containing `.xpt` files. Mandatory.
#' @param fake_study Logical. Whether the study data is generated by the `SENDsanitizer` package. Defaults to `FALSE`.
#' @param use_xpt_file Logical. Whether to retrieve study data from `.xpt` files instead of the SQLite database. Defaults to `FALSE`.
#' @param master_compiledata Optional, character \cr
#'   If `master_compiledata` is not supplied (i.e., `NULL`), the function will automatically call the `get_compile_data` function to calculate it.
#' @param return_individual_scores Optional, logical \cr
#'   If TRUE, the function returns individual scores for each domain by averaging the scores of all subjects/animals (`USUBJID`) in the study. Default is `FALSE`.
#' @param return_zscore_by_USUBJID Optional, logical \cr
#'    If `TRUE`, the function returns Z-scores for each animal/subject by `USUBJID`. Default is `FALSE`.
#'
#' @return
#' A data frame containing the LB Z-scores:
#' - If `return_individual_scores = TRUE`: Returns averaged Z-scores for each  domain per `studyid`.
#' - If `return_zscore_by_USUBJID = TRUE`: Returns Z-score for each animal/subject by `USUBJID` for each domain per `studyid`.
#' - Otherwise, a summarized BW score for the specified `studyid`.
#'
#' @examples
#' \dontrun{
#' note: check kidneytobw function commenting to understand different ways of loading studyid and path_db
#' result_default <- kidney_lb_score(studyid, path_db)
#' result_individual_multiple_score <- kidney_lb_score(studyid, path_db,
#'                                   master_compiledata = NULL,
#'                                   return_individual_scores = TRUE,
#'                                   return_zscore_by_USUBJID = FALSE)
#'
#' result_zscore <- kidney_lb_score(studyid, path_db,
#'                                   master_compiledata = NULL,
#'                                   return_individual_scores = TRUE,
#'                                   return_zscore_by_USUBJID = FALSE)
#' }
#' @importFrom RSQLite dbConnect
#' @importFrom RSQLite SQLite
#' @importFrom magrittr %>%

kidney_lb_score <- function(studyid = NULL,
                            path_db,
                            fake_study = FALSE,
                            use_xpt_file = FALSE,
                            master_compiledata = NULL,
                            return_individual_scores = FALSE,
                            return_zscore_by_USUBJID = FALSE) {

  # ----------------- Helper 1: Fetch Data ----------------------
  # Purpose: General-purpose function to fetch a domain (e.g. LB) from the database for a specific study.
  # Inputs: db_connection (open SQLite connection), domain_name (e.g. "LB"), studyid
  # Output: Returns a data.frame with the query result for the requested domain and study.
  fetch_domain_data <- function(db_connection, domain_name, studyid) {
    domain_name <- toupper(domain_name)
    query_statement <- paste0('SELECT * FROM ', domain_name, " WHERE STUDYID = :x")
    query_result <- DBI::dbGetQuery(db_connection, statement = query_statement, params = list(x = studyid))
    query_result
  }

  # ----------------- Helper 2: Z-Score Calculation ----------------------
  # Purpose: Calculates z-scores for a specified set of LB biomarkers, using VEHICLE group as the reference.
  # Logic: For each row, subtracts the mean of vehicle controls and divides by their SD.
  # Output: Returns data frame with added zscore column (absolute value).
  calculate_zscore <- function(df, test_codes) {
    df %>%
      dplyr::filter(LBTESTCD %in% test_codes) %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::mutate(
        mean_vehicle = mean(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE),
        sd_vehicle = stats::sd(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE)
      ) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        zscore = abs((LBSTRESN - mean_vehicle) / sd_vehicle)
      )
  }

  # ----------------- Helper 3: Z-Score Capping ----------------------
  # Purpose: Ensures z-scores are limited to range 0â€“3, binning all higher/lower values.
  # Output: Integer-capped zscore for interpretation and reporting.
  cap_zscore <- function(zscore) {
    ifelse(zscore >= 3, 3,
           ifelse(zscore >= 2, 2,
                  ifelse(zscore >= 1, 1, 0)))
  }

  # ------------------ Main Function Block: Data Loading ------------------
  # Purpose: Load laboratory (LB) domain data for the given study from either .xpt or SQLite.
  # Outcome: LB data frame for downstream analysis, already filtered to this study.
  studyid <- as.character(studyid)
  path <- path_db

  if (use_xpt_file) {
    lb <- haven::read_xpt(fs::path(path, 'lb.xpt'))
  } else {
    db_connection <- DBI::dbConnect(RSQLite::SQLite(), dbname = path)
    lb <- fetch_domain_data(db_connection, 'lb', studyid)
    DBI::dbDisconnect(db_connection)
  }

  # ------------------ Main Function Block: Biomarker Filtering & Initial Cleaning ------------------
  # Purpose: Extracts only kidney-relevant tests and standardizes the data.
  # Steps:
  # 1. Build canonical KIDNEY test list.
  # 2. Normalize input data (e.g., renaming, removing NAs, concatenating LBSPEC + LBTESTCD).
  # 3. Subset to just kidney-relevant tests.
  organTESTCDlist <- list('KIDNEY' = c('SERUM | CREAT', 'PLASMA | CREAT', 'WHOLE BLOOD | CREAT',
                                       'SERUM | UREAN', 'PLASMA | UREAN', 'WHOLE BLOOD | UREAN',
                                       'SERUM | ALB', 'PLASMA | ALB', 'WHOLE BLOOD | ALB',
                                       'SERUM | CL', 'PLASMA | CL', 'WHOLE BLOOD | CL',
                                       'SERUM | K', 'PLASMA | K', 'WHOLE BLOOD | K',
                                       'SERUM | PHOS', 'PLASMA | PHOS', 'WHOLE BLOOD | PHOS',
                                       'SERUM | SODIUM', 'PLASMA | SODIUM', 'WHOLE BLOOD | SODIUM',
                                       'URINE | CL', 'URINE | K', 'URINE | SODIUM',
                                       'URINE | GLUC', 'URINE | SPGRAV', 'URINE | VOLUME',
                                       'URINE | PROT', 'URINE | UROBIL'))
  LBData <- data.frame("STUDYID" = NA,"USUBJID" = NA,"LBSPEC" = NA,"LBTESTCD" = NA, "LBSTRESN" = NA, "VISITDY" = NA)
  study_data_LB <- lb

  # If LBDY (study day) exists, use it for filtering; otherwise use VISITDY.
  if ("LBDY" %in% names(study_data_LB)) {
    LBD <- study_data_LB %>%
      dplyr::filter(LBDY >= 1) %>%
      dplyr::select(STUDYID, USUBJID, LBSPEC, LBTESTCD, LBSTRESN, LBDY)
    colnames(LBD) <- c("STUDYID", "USUBJID", "LBSPEC", "LBTESTCD", "LBSTRESN", "VISITDY")
  } else {
    LBD <- study_data_LB[which(study_data_LB$VISITDY >= 1),
                         c("STUDYID", "USUBJID", "LBSPEC", "LBTESTCD", "LBSTRESN", "VISITDY")]
  }

  LBData <- rbind(LBData, LBD)
  LBData <- stats::na.omit(LBData)  # Remove rows with all NAs
  LBData$LBTESTCD <- paste(LBData$LBSPEC, LBData$LBTESTCD, sep = ' | ')  # Create canonical test code
  test_cleaned_LBData <- LBData[LBData$LBTESTCD %in% organTESTCDlist[['KIDNEY']],]

  # ------------------ Main Function Block: Latest Visit per USUBJID/test ------------------
  # Purpose: For each subject and test, use only the measurement from the latest study day (to avoid duplicates).
  # Outcome: A table with only the most recent result for each animal and biomarker.
  max_visitdy_df <- test_cleaned_LBData %>%
    dplyr::group_by(USUBJID, LBTESTCD) %>%
    dplyr::filter(VISITDY == max(VISITDY, na.rm = TRUE)) %>%
    dplyr::ungroup()

  # ------------------ Main Function Block: Filter by Master Compile Data ------------------
  # Purpose: Remove animals that are not in the compiled master (e.g. exclude TK, recovery).
  # Outcome: Only main study animals included in analysis.
  if (is.null(master_compiledata)) {
    master_compiledata <- get_compile_data(studyid = studyid,
                                           path_db = path_db,
                                           fake_study = fake_study,
                                           use_xpt_file = use_xpt_file)
  }
  LB_tk_recovery_filtered <- max_visitdy_df %>%
    dplyr::filter(USUBJID %in% master_compiledata$USUBJID)
  LB_tk_recovery_filtered_ARMCD <- LB_tk_recovery_filtered %>%
    dplyr::inner_join(master_compiledata %>% dplyr::select(USUBJID, ARMCD), by = "USUBJID")

  # ------------------ Main Function Block: Per-Biomarker Z-score Table Assembly ------------------
  # Purpose: For each kidney biomarker, calculate the (group-capped) mean Z-score for the high-dose group.
  # Logic: Loop through each biomarker, compute scores, and combine all results by STUDYID.
  # Outcome: A table with columns like avg_creat_zscore, avg_urean_zscore, etc. per study.
  biomarkers <- list(
    CREAT = c("SERUM | CREAT", "PLASMA | CREAT", "WHOLE BLOOD | CREAT"),
    UREAN = c("SERUM | UREAN", "PLASMA | UREAN", "WHOLE BLOOD | UREAN"),
    ALB = c("SERUM | ALB", "PLASMA | ALB", "WHOLE BLOOD | ALB"),
    CL = c("SERUM | CL", "PLASMA | CL", "WHOLE BLOOD | CL"),
    K = c("SERUM | K", "PLASMA | K", "WHOLE BLOOD | K"),
    PHOS = c("SERUM | PHOS", "PLASMA | PHOS", "WHOLE BLOOD | PHOS"),
    SODIUM = c("SERUM | SODIUM", "PLASMA | SODIUM", "WHOLE BLOOD | SODIUM"),
    URINE_CL = c("URINE | CL"),
    URINE_K = c("URINE | K"),
    URINE_SODIUM = c("URINE | SODIUM"),
    URINE_GLUC = c("URINE | GLUC"),
    URINE_SPGRAV = c("URINE | SPGRAV"),
    URINE_VOLUME = c("URINE | VOLUME"),
    URINE_PROT = c("URINE | PROT"),
    URINE_UROBIL = c("URINE | UROBIL")
  )

  scores_list <- lapply(names(biomarkers), function(name) {
    # For each biomarker group, calculate mean Z-score in HD animals, cap it, and summarize
    calculate_zscore(LB_tk_recovery_filtered_ARMCD, biomarkers[[name]]) %>%
      dplyr::filter(ARMCD == "HD") %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::summarise(!!paste0("avg_", tolower(name), "_zscore") := cap_zscore(mean(zscore, na.rm = TRUE)))
  })

  # Merge all biomarker-specific scores into one table per study
  final_scores <- purrr::reduce(scores_list, dplyr::full_join, by = "STUDYID")

  # ------------------ Main Function Block: Output Logic ------------------
  # Purpose: Return different outputs based on user flags.
  # If individual scores flag is set: return the full per-biomarker score table for each study.
  # If per-animal Z-score flag is set: return z-scores per USUBJID for high-dose animals.
  # Otherwise: return a single mean-of-all-LB-scores summary per study.
  if (return_individual_scores) {
    # Outcome: Dataframe with mean z-scores for each biomarker in HD group per STUDYID
    return(final_scores)
  }

  # Add a column for the overall mean LB z-score across all tested biomarkers
  final_scores$avg_all_LB_zscores <- rowMeans(dplyr::select(final_scores, starts_with("avg_")), na.rm = TRUE)

  if (return_zscore_by_USUBJID) {
    # Outcome: Dataframe with capped LB z-score for every high-dose animal for this study
    df_lb_for_zscore <- LB_tk_recovery_filtered_ARMCD
    zscore_lb <- df_lb_for_zscore %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::mutate(
        mean_vehicle = mean(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE),
        sd_vehicle = stats::sd(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE),
        LB_zscore = abs((LBSTRESN - mean_vehicle) / sd_vehicle)
      ) %>%
      dplyr::ungroup() %>%
      dplyr::filter(ARMCD == "HD") %>%
      dplyr::select(STUDYID, USUBJID, LB_zscore) %>%
      dplyr::mutate(LB_zscore = cap_zscore(LB_zscore))
    return(as.data.frame(zscore_lb))
  }

  # Default: return overall mean LB z-score across all biomarkers for each study
  averaged_LB_score <- final_scores %>% dplyr::select(STUDYID, avg_all_LB_zscores)
  return(as.data.frame(averaged_LB_score))
}
