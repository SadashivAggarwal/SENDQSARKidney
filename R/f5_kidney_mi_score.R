#' @title Get Microscopic Findings (MI) domain Z-score for a given STUDYID from SQLite Database or `.xpt` Files
#'
#' @description
#' This function calculates the MI score for a given STUDYID using data stored in a specified database.
#' Organ difference: The only difference between Kidney_mi vs. Liver_mi is in filtering by organism.
#'
#' @param studyid Character. STUDYID number. Defaults to `NULL`.
#'    Required for SQLite databases (`use_xpt_file = FALSE`).
#'    Must be `NULL` for `.xpt` files (`use_xpt_file = TRUE`).
#' @param path_db Character. Path to the SQLite database file or a folder containing `.xpt` files. Mandatory.
#' @param fake_study Logical. Whether the study data is generated by the `SENDsanitizer` package. Defaults to `FALSE`.
#' @param use_xpt_file Logical. Whether to retrieve study data from `.xpt` files instead of the SQLite database. Defaults to `FALSE`.
#' @param master_compiledata Optional. If `NULL`, the function will call `get_compile_data` to generate it.
#' @param return_individual_scores Logical. If `TRUE`, returns average scores for specified findings and highest_score per study. Defaults to `FALSE`.
#' @param return_zscore_by_USUBJID Logical. If `TRUE`, returns Z-scores by `USUBJID`. Defaults to `FALSE`.
#'
#' @return
#' - If `return_individual_scores = TRUE`: A data frame with columns: `STUDYID`, `Mineralization`, `Infiltrate`, `Unremarkable`, and `highest_score`.
#' - If `return_zscore_by_USUBJID = TRUE`: Returns full scored data by subject.
#' - Otherwise: average MI_score per study.
#'
#' @export
#'
#' Expected outcome/Data frames; 1) when return_zscore_by_USUBJID = TRUE
#' STUDYID  USUBJID  MINERALIZATION  INFILTRATE  UNREMARKABLE  highest_score
#' 001  101 2 1 0 2
#' 001  102 1 3 0 3
#' 001  103 0 2 0 2
#'
#' 2) When return_individual_scores = TRUE, you get aggregation of above:
#'   The mean for each column: MINERALIZATION: (2 + 1 + 0)/3 = 1, INFILTRATE: (1 + 3 + 2)/3 ≈ 2
#'   STUDYID MINERALIZATION INFILTRATE UNREMARKABLE highest_score
#'   001 1.0 2.0 0.0 2.33
#'
#'   3) For default parameters (return_zscore_by_USUBJID = FALSE, return_individual_scores = FALSE).
#' Calculation: MI_avg_score will be the avg of highest_score only. Here, for single studyID 001, it’ll be 2+3+2 = 7/3 = 2.33
#' STUDYID  MI_avg_score
#' 001 2.33

kidney_mi_score <- function(
    studyid = NULL,
    path_db,
    fake_study = FALSE,
    use_xpt_file = FALSE,
    master_compiledata = NULL,
    return_individual_scores = FALSE,
    return_zscore_by_USUBJID = FALSE
) {
  
  # --- 1. HELPER: DATA FETCHING ---
  # Fetches MI or DM data from either SQLite DB or .xpt file depending on input flags
  fetch_domain_data <- function(path, domain, use_xpt, db_conn, studyid) {
    if (use_xpt) {
      haven::read_xpt(fs::path(path, paste0(domain, '.xpt')))
    } else {
      sql <- sprintf('SELECT * FROM %s WHERE STUDYID = :x', toupper(domain))
      DBI::dbGetQuery(db_conn, statement = sql, params = list(x = studyid))
    }
  }
  
  # --- 2. HELPER: SEVERITY CONVERSION ---
  # Standardizes severity codes (e.g., 'MINIMAL', '1 OF 5') to ordered numeric factors (0-5)
  convert_severity <- function(misev) {
    lookup <- c(
      "1 OF 4" = "2", "2 OF 4" = "3", "3 OF 4" = "4", "4 OF 4" = "5",
      "1 OF 5" = "1", "MINIMAL" = "1", "2 OF 5" = "2", "MILD" = "2",
      "3 OF 5" = "3", "MODERATE" = "3", "4 OF 5" = "4", "MARKED" = "4",
      "5 OF 5" = "5", "SEVERE" = "5"
    )
    misev <- stringr::str_replace_all(misev, lookup)
    misev[misev == "" | is.na(misev)] <- "0"
    factor(misev, levels = c("0","1","2","3","4","5"), ordered = TRUE)
  }
  
  # --- 3. HELPER: MI DATA PREPARATION ---
  # Filters for kidney-specific findings and cleans/standardizes text and severity
  prepare_mi_data <- function(midata) {
    midata %>%
      dplyr::filter(stringr::str_detect(toupper(MISPEC), 'KIDNEY')) %>%
      dplyr::mutate(
        MISEV = convert_severity(MISEV),
        MISTRESC = toupper(MISTRESC)
      ) %>%
      dplyr::filter(MISTRESC != '')
  }
  
  # --- 4. HELPER: INCIDENCE CORRECTION ---
  # Raises minimum severity if a finding is common (incidence-based logic, see SEND guidelines)
  apply_incidence_correction <- function(scored, raw_mi) {
    inc <- raw_mi %>%
      dplyr::filter(ARMCD == 'HD') %>%
      dplyr::group_by(MISTRESC) %>%
      dplyr::summarise(Incidence = n() / n_distinct(USUBJID), .groups = 'drop')
    
    cols <- colnames(scored)[7:(ncol(scored) - 1)]
    for (f in cols) {
      if (f %in% inc$MISTRESC) {
        rate <- inc$Incidence[inc$MISTRESC == f]
        scored[[f]] <- ifelse(
          rate >= 0.75, pmax(scored[[f]], 5),
          ifelse(rate >= 0.5, pmax(scored[[f]], 3),
                 ifelse(rate >= 0.25, pmax(scored[[f]], 2),
                        ifelse(rate >= 0.1, pmax(scored[[f]], 1), scored[[f]]))))
      }
    }
    scored
  }
  
  # --- 5. HELPER: HIGHEST SCORE CALCULATION ---
  # For each subject/row, records the maximum severity across all findings
  calculate_highest_score <- function(df) {
    df$highest_score <- matrixStats::rowMaxs(as.matrix(df[, 7:ncol(df)]), na.rm = TRUE)
    df
  }
  
  # --- MAIN WORKFLOW STARTS HERE ---
  
  # 1. Handle Inputs and Data Fetching
  # Converts studyid, sets paths, and loads MI & DM data for the specified study and input mode
  studyid <- as.character(studyid)
  path <- path_db
  if (!use_xpt_file) db_conn <- DBI::dbConnect(RSQLite::SQLite(), dbname = path)
  mi <- fetch_domain_data(path, 'mi', use_xpt_file, if (!use_xpt_file) db_conn else NULL, studyid)
  dm <- fetch_domain_data(path, 'dm', use_xpt_file, if (!use_xpt_file) db_conn else NULL, studyid)
  if (!use_xpt_file) DBI::dbDisconnect(db_conn)
  
  # If MI domain is empty, exit early with a warning
  if (nrow(mi) == 0) return(data.frame(STUDYID = unique(dm$STUDYID), Warning = "'mi' is empty"))
  
  # 2. Data Preparation
  # Prepares kidney-only MI data and joins with master metadata for subject info
  mi_clean <- prepare_mi_data(mi)
  if (is.null(master_compiledata)) {
    master_compiledata <- get_compile_data(studyid, path_db, fake_study, use_xpt_file)
  }
  mi_full <- dplyr::inner_join(mi_clean, master_compiledata, by = 'USUBJID')
  if (all(mi_full$ARMCD %in% c('VEHICLE', 'Vehicle', 'vehicle'))) stop('Only vehicle data found.')
  
  # 3. Data Transformation
  # Reshapes to wide format (one row per subject), drops "NORMAL" findings, and checks that findings exist
  wide <- mi_full %>%
    dplyr::group_by(USUBJID, MISTRESC) %>%
    dplyr::summarise(MISEV = max(as.numeric(as.character(MISEV)), na.rm = TRUE), .groups = 'drop') %>%
    tidyr::pivot_wider(names_from = MISTRESC, values_from = MISEV, values_fill = 0)
  wide <- dplyr::inner_join(master_compiledata, wide, by = 'USUBJID')
  if ('NORMAL' %in% colnames(wide)) wide <- dplyr::select(wide, -NORMAL)
  if (ncol(wide) <= 6) stop('No MI findings to calculate.')
  
  # 4. Numeric Conversion & Scoring
  # Applies numeric conversion, scoring logic, and incidence correction for high-dose animals
  wide[, 7:ncol(wide)] <- lapply(wide[, 7:ncol(wide)], as.numeric)
  scored <- wide %>%
    dplyr::filter(ARMCD == 'HD') %>%
    dplyr::mutate(dplyr::across(7:ncol(.), ~ dplyr::case_when(
      . == 5 ~ 5,
      . > 3 ~ 3,
      . == 3 ~ 2,
      . > 0 ~ 1,
      TRUE ~ 0
    )))
  scored <- apply_incidence_correction(scored, mi_full)
  scored <- calculate_highest_score(scored)
  
  # 5. Output Logic
  # Returns: (a) mean by finding (if return_individual_scores),
  #          (b) animal-level scored data (if return_zscore_by_USUBJID), or
  #          (c) study-level MI_avg_score (default)
  if (return_individual_scores) {
    findings_cols <- intersect(colnames(scored), c('MINERALIZATION', 'INFILTRATE', 'UNREMARKABLE'))
    results <- scored %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::summarise(
        dplyr::across(all_of(findings_cols), ~ mean(.x, na.rm = TRUE)),
        highest_score = mean(highest_score, na.rm = TRUE),
        .groups = 'drop'
      )
    rename_map <- c('MINERALIZATION' = 'Mineralization',
                    'INFILTRATE' = 'Infiltrate',
                    'UNREMARKABLE' = 'Unremarkable')
    results <- dplyr::rename_with(results, ~ rename_map[.x], all_of(findings_cols))
    return(results)
  }
  
  if (return_zscore_by_USUBJID) {
    return(scored)
  }
  
  avg <- scored %>%
    dplyr::group_by(STUDYID) %>%
    dplyr::summarise(MI_avg_score = mean(highest_score, na.rm = TRUE), .groups = 'drop')
  avg
  
}
